## INTRO
* This section is concerned with mathematical exploits in coding challenges, Combinatorics. 

## Lexicographic Orderness 

* Normal Lexicographic order
	* given 2 sequences there are 2 cases: 
		* They have the same length, then compare the sequence element wise using an alphabet to determine the relative size of the sequence. 
		* They have different length, pad the shorter one with a symbols that ranks lower than ALL characters on the alphabet.
	* A variance involves comparing the length of the sequences and always rank shorter sequence smaller, and then it proceed to compare the symbols in the sequence afterwards. It's called **shortlex**
* For the sake of discussion, let's limit the set of alphabet to be `a-z`, lowercased English letters. 
* Fact: Lexicographic orderness are transitive, hence **total order**[^1]

[^1]: Axioms: $a\leq b \wedge b\leq a \implies a = b$; $a\leq b \wedge b\leq c \implies a\leq c$, $a \leq b \vee b\leq a$.


### A Problem
* Given a collection of integers, arrange them in a permutation and then concatenate them like a string, find such a permutations that produce the lexicographical maximal string. 
* This is leetcode problem, [link](https://leetcode.com/problems/largest-number/)

### Discussion
* Consider we have 2 strings, `S1`, `S2`, and we want to determine whether the permutation `S1+S2` is larger or `S2+S1` is lager, which is simply, we do it just by comparing `S1 + S2` with `S2 + S1`. 
* Now, consider that we are given 3 strings, where `A, B, C` are string of non zero length, in this order`ABC`, and we want to find the minimal lexicographic order permutations of the block of strings.
* If, moving `C` to the front make it smaller, then `CAB <= ABC`, let's denote it as `C<<AB`. 
* If, moving `C` to `B` makes it smaller, then `ACB <= ACB`, which is `CB<=BC`, then `C<<B`. 
* Here, we natrually developed the notation of `a<<b` which means `ab<=ba` in lexicographical order.

## A Naive Algorithm is Made 
* Here, we can use the route of **bubble sort** or insertion sort to determine the best, minimal/maximal permutation. Let's focus on bubble sort.
* Let's say we have a fancier groups of strings, in a certain permutation.

$$
	(S_1)(S_2)(S_3)... (S_i)(S_j)... (S_n)
$$

* We wask: "does swapping $S_i$ with $S_j$ make it lexicographically smaller?"
* Notice that, adjacent swaps of $S_i, S_j$ won't change the prefix from $S_1$ up to $S_{i - 1}$ and the postfix where $S_{j + 1}$ to $S_{n}$ so then, the only comparison which can make the difference is the substring $(S_i)(S_j)$ and $(S_j)(S_i)$. 
* Hence, we swap $S_i, S_j$ if $(S_j)(S_i)\leq (S_i)(S_j)$, else we don't. Or using our fancier notation, we swap it if $S_j << S_i$
* Why it works? 
* Assuming a base case of 2 string, the bubble sort algorithm will determine the minmial permutation. 
* Then, the first swap will assert that, the first block of string is in the correct order, $({S'}_1)...(S'_{n})$ are in the correct order.  (The `'` denotes that the bubble sort already touched it and it's the permutation afterwards, with the new index), string that starts with another other $S \neq {S'}_i$ will be larger than the string produced by the first bubble sort.
	* This part is asserted by the fact that, lexicographic orderness is **total order**
* There is something *HUGE* that has been missing in this proof... that is: the operator `<<` is transitive, that is, **bubble sort didn't  use the exploit** that, if $A << B$ and $B << C$, then $A << C$, if this is not the case, that it's possible that, after 2 swaps, the element swapped 2 steps in advance might be smaller than the element that got moved. 
* $CBA$, $CAB$, $ACB$, 2 swaps asserts that $A<<B$, $A<<C$, no transitivity is needed to change the permutations here.

## Huh... 
* Good news, we know that, lexicographic order is a **total order**. 
* Bad news, what kind of structure does the se of string and the binary operation "<<" present to us exactly???
* If, our newly defined operator is indeed **transitive**, then, any sorting algorithms will work and it has **connexity**, then we will be good to go.

### Transitive
$$
	(A << B)\wedge(B << C) \implies A << C
$$
Which by our definition it's gonna be: 
$$
	[(A)(B) \leq (B)(A)]\wedge[(B)(C)\leq (C)(B)]\implies [(A)(C)\leq (C)(A)]
$$
